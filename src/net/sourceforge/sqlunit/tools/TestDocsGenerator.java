/*
 * $Id: TestDocsGenerator.java,v 1.1 2005/06/07 01:13:38 spal Exp $
 * $Source: /cvsroot/sqlunit/sqlunit/src/net/sourceforge/sqlunit/tools/TestDocsGenerator.java,v $
 * SQLUnit - a test harness for unit testing database stored procedures.
 * Copyright (C) 2003  The SQLUnit Team
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package net.sourceforge.sqlunit.tools;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.Iterator;
import java.util.TreeSet;

import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

/**
 * This class converts output XML files generated by SQLUnit using Canoo as
 * the reporter to XHTML which can then be viewed in a browser.
 * This class will recursively trace through all directories looking for SQLUnit
 * XML files, open each file, and extract the test name information from each.
 *
 * @author James Henderson
 * @version $Revision: 1.1 $
 */
public class TestDocsGenerator {

    /** Base index of DTD constants */
    private static final int DTD_BASE_INDEX = 0;
    /** Index of XHTML Strict DTD */
    private static final int DTD_XHTML_STRICT = DTD_BASE_INDEX + 0;
    /** Index of XHTML Transitional DTD */
    private static final int DTD_XHTML_TRANSITIONAL = DTD_BASE_INDEX + 1;
    /** Index of XHTML Frameset DTD */
    private static final int DTD_XHTML_FRAMESET = DTD_BASE_INDEX + 2;
    /** Directory of test as an XHTML file */
    private final String OUTPUT_XHTML_FILE_NAME = "TestDirectory.html";
    /** Index of Test cases as an XHTML file */
    private final String OUTPUT_XHTML_FILE_NAME_INDEX = "TestCaseIndex.html";
    /** Frameset of output files as an XHTML file */
    private final String OUTPUT_XHTML_FILE_NAME_FRAME = "TestCaseFrameset.html";
    /** XSL Transform used to extract test directory information */
    private final String XSLT_FILE_NAME = "etc/canoo2html_dir_transform.xsl";

    /** The test directory used to generate information */
    private File m_testDir = null;
    /** The output directory path */
    private String m_outputDir = null;
    /** File extension filter */
    private FileExtFilter m_filter = null;
    /** Collection of all test files */
    private TreeSet m_fileCollection = null;
    /** Number of files processed */
    private int m_numTestCases = 0;

    /**
     * Main entry point into application
     * @param args Command Line arguments; use arg[0] to provide absolute path
     * to directory containing SQLUnit directories and files to be processed
     */
    public static void main(String[] args) {
        if (args.length != 2) {
            System.out.println(
                "Usage: java net.sourceforge.sqlunit.tools."
                + "TestDocsGenerator <pathToTestCases> "
                + "<outputDirectory>");
            return;
        }
        TestDocsGenerator tdg =
            new TestDocsGenerator(args[0], args[1]);
        tdg.makeOutputDirectory(tdg.getOutputDirectory());
        tdg.getDirectoryContents(tdg.getTestDirectory());
        tdg.createTestInfoListing();
        System.out.println("Number of test cases processed:"
                + tdg.getNumTestCases());
        tdg.terminate();
        tdg = null;
    }

    /**
     * Constructor for GenerateTestInfo.
     * @param dirToExamine the directory to examine
     */
    public TestDocsGenerator(String dirToExamine, String outputDir) {
        m_testDir = new File(dirToExamine);
        m_outputDir = outputDir;
        m_filter = new FileExtFilter(".xml");
        m_fileCollection = new TreeSet();
        m_numTestCases = 0;
    }

    /**
     * Start the XHTML Template.
     * @param out PrintWriter used to create XHTML file
     * @param title Title used within XHTML template
     * @param dtdType The DTD to use within the DOCTYPE tag
     * @param omitBodyTag Flag to indicate that <body> tag should be omitted
     */
    private void beginXHTMLTemplate(PrintWriter out, String title, int dtdType,
            boolean omitBodyTag) {
        /** XHTML 1.0 Strict DTD */
        final String DTD_XHTML_STRICT_DOCTYPE = "<!DOCTYPE html "
                + "PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" "
                + "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">";
        /** XHTML 1.0 Transitional DTD */
        final String DTD_XHTML_TRANSITIONAL_DOCTYPE = "<!DOCTYPE html "
                + "PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" "
                + "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">";
        /** XHTML 1.0 Frameset DTD */
        final String DTD_XHTML_FRAMESET_DOCTYPE = "<!DOCTYPE html "
                + "PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" "
                + "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">";
        /** Array of DTD DOCTYPE tags */
        final String[] DTD_DOCTYPES = { DTD_XHTML_STRICT_DOCTYPE,
                DTD_XHTML_TRANSITIONAL_DOCTYPE, DTD_XHTML_FRAMESET_DOCTYPE };
        final String DOC_CONTENT_TAG = "<meta http-equiv=\"Content-Type\""
            + " content=\"text/html;charset=utf-8\" />";
        //
        // Write out XHTML valid template before processing each file and
        // obtaining XHTML fragments from the transform
        //

        // It isn't required to output an <?xml ... ?> tag, but it is "strongly
        // encouraged". See http://www.w3.org/TR/xhtml1/#strict, section 3.1.1
        out.println("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");

        // A <!DOCTYPE ...> instruction is required for
        // a valid XHTML document. (See obtainTransformer function)
        out.println(DTD_DOCTYPES[dtdType]);
        out.println("<html lang=\"en\" xml:lang=\"en\" "
            + "xmlns=\"http://www.w3.org/1999/xhtml\">");
        out.println("    <head>");
        out.println("        " + DOC_CONTENT_TAG);
        out.print("        <title>");
        out.print("Listing of Available Tests for ");
        out.print(title);
        out.println("</title>");
        out.println("    </head>");
        if (!omitBodyTag) {
            out.println("    <body>");
        }
    }

    /**
     * Complete the XHTML Template
     * @param out PrintWriter used to create XHTML file
     * @param omitBodyTag Flag to indicate that <body> tag should be omitted
     */
    private void endXHTMLTemplate(PrintWriter out, boolean omitBodyTag) {
        if (!omitBodyTag) {
            out.println("    </body>");
        }
        out.println("</html>");
    }

    /**
     * Create a listing of all tests within each test case
     */
    public void createTestInfoListing() {
        try {
            File f = new File(".");
            Transformer transformer = obtainTransformer(XSLT_FILE_NAME);
            // Establish the file that will hold the resulting XHTML files
            File xhtmlFile = new File(m_outputDir + File.separator
                    + OUTPUT_XHTML_FILE_NAME);
            File xhtmlFileIndex = new File(m_outputDir + File.separator
                    + OUTPUT_XHTML_FILE_NAME_INDEX);
            File xhtmlFileFrame = new File(m_outputDir + File.separator
                    + OUTPUT_XHTML_FILE_NAME_FRAME);
            // Remove the files if they exist
            xhtmlFile.delete();
            xhtmlFileIndex.delete();
            xhtmlFileFrame.delete();
            // Create a writers to write to the appropriate XHTML files
            PrintWriter out = new PrintWriter(new FileWriter(xhtmlFile), true);
            PrintWriter outIndex = new PrintWriter(new FileWriter(
                    xhtmlFileIndex), true);
            PrintWriter outFrames = new PrintWriter(new FileWriter(
                    xhtmlFileFrame), true);
            beginXHTMLTemplate(out, m_testDir.getCanonicalPath(),
                    DTD_XHTML_STRICT, false);
            beginXHTMLTemplate(outIndex, m_testDir.getCanonicalPath(),
                    DTD_XHTML_STRICT, false);
            beginXHTMLTemplate(outFrames, m_testDir.getCanonicalPath(),
                    DTD_XHTML_FRAMESET, true);
            // Generate the frameset
            generateFrameset(outFrames);
            // Write a heading to the index
            outIndex.println("<div style=\"font-weight: "
                + "bold; font-size: larger;\">Index of Test Cases</div>");
            // Process each file in turn
            for (Iterator iter = m_fileCollection.iterator(); iter.hasNext();) {
                TestFileCollection tfc = (TestFileCollection) iter.next();
                String testCaseFileName = tfc.getTestCaseFileName();
                String testCaseName = tfc.getTestCaseName();
                System.out.println("Processing " + testCaseFileName + ":" + testCaseName);
                outIndex.println("    <a href=\"" + OUTPUT_XHTML_FILE_NAME
                        + "#" + testCaseName + "\" target=\"frameContent\">"
                        + testCaseName + "</a><br />");
                // Set up an XML source to be processed
                StreamSource xmlSource = new StreamSource(new FileInputStream(
                        new File(testCaseFileName)));
                // Perform the transformation
                StringWriter strWriter = new StringWriter();
                transformer.setParameter("testCaseFileName", testCaseFileName);
                transformer.transform(xmlSource, new StreamResult(strWriter));
                // Extract the result of the XML transform
                BufferedReader transformResult = new BufferedReader(
                        new StringReader(strWriter.toString()));
                String lineOutput = null;
                while ((lineOutput = transformResult.readLine()) != null) {
                    // The XSL Transform provides a doctype as part of the
                    // <xsl:output>
                    // tag. Strip it out, since we provide our own.
                    if (!lineOutput.startsWith("<!DOCTYPE")) {
                        out.println(lineOutput);
                    }
                }
                transformResult = null;
                strWriter = null;
                xmlSource = null;
            }
            // Finish up the XHTML templates
            endXHTMLTemplate(outFrames, true);
            endXHTMLTemplate(outIndex, false);
            endXHTMLTemplate(out, false);
            outFrames.close();
            outIndex.close();
            out.close();
        } catch (TransformerException e) {
            e.printStackTrace();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * This function will generate a frameset that will display the test
     * directory and the test case index using HTML frames
     * 
     * @param outFrames -
     *            PrintWriter used to create XHTML file
     */
    private void generateFrameset(PrintWriter outFrames) {
        outFrames.println();
        outFrames.println("    <frameset  cols=\"33%,*\">");
        outFrames.println("        <frame name=\"frameIndex\" src=\""
            + OUTPUT_XHTML_FILE_NAME_INDEX
            + "\" marginwidth=\"10\" marginheight=\"10\" "
            + "scrolling=\"auto\" frameborder=\"1\">");
        outFrames.println("        <frame name=\"frameContent\" src=\""
            + OUTPUT_XHTML_FILE_NAME
            + "\" marginwidth=\"10\" marginheight=\"10\" "
            + "scrolling=\"auto\" frameborder=\"1\">");
        outFrames.println("    </frameset>");
        outFrames.println();
        outFrames.println("    <noframes>You must use a browser that "
            + "supports frames in order to view this document.</noframes>");
        outFrames.println();
        return;
    }

    /**
     * Obtain a collection of all the files within a specified directory and all
     * sub-directories
     * @param dir The specified directroes to retrieve a file collection from
     */
    public void getDirectoryContents(File dir) {
        if (!dir.isDirectory())
            return;
        try {
            // Get the list of directory contents. If we have a filter then
            // use it otherwise default to everything.
            String[] contents = (m_filter != null)
                ? dir.list(m_filter) : dir.list();
            // Get the collection of all the files
            for (int i = 0; i < contents.length; i++) {
                File f = new File(dir.getPath(), contents[i]);
                if (f.isDirectory()) {
                    getDirectoryContents(new File(f.getPath()));
                }
                if (f.isFile()) {
                    String testCaseFileName = f.getCanonicalPath();
                    String testCaseName = testCaseFileName.substring(
                            testCaseFileName.lastIndexOf(File.separator) + 1,
                            testCaseFileName.lastIndexOf("."));

                    m_fileCollection.add(new TestFileCollection(
                            testCaseFileName, testCaseName));
                    m_numTestCases++;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Makes the output directory if it does not already exist.
     * @param outputDirectory the full path name to the output directory.
     */
    public void makeOutputDirectory(String outputDirectory) {
        try {
            File fod = new File(outputDirectory);
            if (fod.exists()) {
                if (!fod.isDirectory()) {
                    throw new Exception("The path " + outputDirectory
                        + " refers to an existing file,"
                        + " cannot create directory!");
                }
            } else {
                fod.mkdirs();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Obtain the test directory as a java.io.File
     * @return The test directory as a java.io.File
     */
    public File getTestDirectory() {
        return m_testDir;
    }

    /**
     * Obtain the output directory as a String.
     * @return the output directory name.
     */
    public String getOutputDirectory() {
        return m_outputDir;
    }

    /**
     * Obtain the number of test cases
     * @return The number of test cases
     */
    public int getNumTestCases() {
        return m_numTestCases;
    }

    /**
     * Obtain a Transformer object associated with a given XSL Transform
     * @param xsltFilename -
     *            the file name of the XSL Transform
     * @return The instance of the Transformer associated with the filename
     */
    private Transformer obtainTransformer(String xsltFilename) {
        Transformer transformer = null;

        try {
            // Create a source for the XSL Transform
            StreamSource xsltSource = new StreamSource(new FileInputStream(
                    new File(xsltFilename)));
            // Create the Transformer Factory
            TransformerFactory tf = TransformerFactory.newInstance();
            // Create the Transformer
            transformer = tf.newTransformer(xsltSource);
            //
            // Set up the output properties of the transformer
            //
            // Omit the XML declaration, since we may be processing multiple
            // files
            // and the transform will yield an XHTML fragment. As a result,
            // we'll
            // output it ourselves.
            transformer.setOutputProperty(
                OutputKeys.OMIT_XML_DECLARATION, "yes");
            // Set the indent amount
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");
            transformer.setOutputProperty(
                "{http://xml.apache.org/xslt}indent-amount", "4");
            transformer.setOutputProperty(OutputKeys.METHOD, "html");
            // Note: As of Java 1.4.2, using the OutputKeys.DOCTYPE_PUBLIC
            // does not provide a doctype tag when outputting XML
            // documents, only HTML documents. However, all XHTML
            // documents require a DOCTYPE declaration prior to the
            // <html> root element, according to the W3C specification.
            // We will output it ourselves, since the
            // java.xml.transform.Transformer insists on outputting
            // the DOCTYPE name as "HTML" rather than "html". This is
            // significant, since the the root element of all XHTML
            // documents is "<html>" (not <HTML>), and as a result will
            // cause problems with document validation.
            transformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC,
                    "-//W3C//DTD XHTML 1.0 Strict//EN");
            transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM,
                    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd");
            // Set the media type as "text/html" per W3C recommendations.
            // See http://www.w3.org/TR/xhtml1/#issues, Section 5.1
            // We will output the content type ourselves within a <META> tag.
            transformer.setOutputProperty(OutputKeys.MEDIA_TYPE, "text/html");
        } catch (TransformerException e) {
            e.printStackTrace();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        return transformer;
    }

    /**
     * Print the entire collection of files.
     */
    public void printFileCollection() {
        for (Iterator i = m_fileCollection.iterator(); i.hasNext();) {
            System.out.println(((TestFileCollection) i.next())
                    .getTestCaseFileName());
        }
    }

    /**
     * Perform cleanup functions up termination
     */
    public void terminate() {
        m_testDir = null;
        m_filter = null;

        m_fileCollection.clear();
        m_fileCollection = null;
    }

    // Member classes 
    
    /**
     * This class will provide a file filter. Only files with the specified
     * extension will be allowed. The filter does not apply to directories.
     */
    private class FileExtFilter implements FilenameFilter {
        
        /** Extension used within filter (for files only) */
        private String m_ext = null;

        /**
         * Constructor for FileExtFilter
         * @param extension Extension used to filter files
         */
        public FileExtFilter(String extension) {
            m_ext = extension;
        }

        /**
         * Tests if a specified file should be included in a file list.
         * @param dir the directory in which the file was found.
         * @param name the name of the file.
         * @return <code>true</code> if and only if the name should be
         * included in the file list; <code>false</code> otherwise.
         */
        public boolean accept(File dir, String name) {
            boolean includeFile = false;
            File f = new File(dir, name);
            includeFile = (name.endsWith(m_ext)) || (f.isDirectory());
            f = null;
            return includeFile;
        }
    }

    /**
     * An object that holds the test filename and test file. This is used to
     * sort all test files by test case name
     */
    private class TestFileCollection implements Comparable {
        /**Path and filename of the test case */
        private String m_testCaseFileName;
        /** Name of the test case */
        private String m_testCaseName;

        /**
         * Constructor for File collection
         * @param fileName the filename of the test
         * @param testCaseName the name of the test
         */
        public TestFileCollection(String fileName, String testCaseName) {
            m_testCaseFileName = fileName;
            m_testCaseName = testCaseName;
        }

        /**
         * Compares its two TestFileCollection instances for order
         * @param o1 the TestFileCollection object to be compared.
         * @return A negative integer, zero, or a positive integer as this
         * object is less than, equal to, or greater than the specified
         * object.
         */
        public int compareTo(Object o1) {
            return (m_testCaseName.compareTo(((TestFileCollection) o1)
                    .getTestCaseName()));
        }

        /**
         * Retrieve the test case name associated with this object
         * @return The test case name
         */
        public String getTestCaseName() {
            return m_testCaseName;
        }

        /**
         * Retrieve the test case file name associated with this object
         * @return The test case file name
         */
        public String getTestCaseFileName() {
            return m_testCaseFileName;
        }
    }
}
