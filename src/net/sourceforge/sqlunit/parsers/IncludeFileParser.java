/* Generated By:JavaCC: Do not edit this line. IncludeFileParser.java */
package net.sourceforge.sqlunit.parsers;

import java.io.Reader;
import java.util.List;
import java.util.ArrayList;

/**
 * The IncludeFileParser uses the embedded JavaCC grammar to parse the
 * named file in the include.file attribute.
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.1 $
 */
public final class IncludeFileParser implements IncludeFileParserConstants {

    private static final String MULTILINE_SQL_PREFIX = "M:";
    private static final String CALLABLE_SQL_PREFIX = "C:";
    private static final String SHELL_CALL_PREFIX = "S:";
    private static final String OTHER_SQL_PREFIX = "O:";

    public static final List parse(final Reader fileReader)
            throws ParseException {
        IncludeFileParser parser = new IncludeFileParser(fileReader);
        return parser.StatementCollection();
    }

// An include file is a collection of statements separated by one of the
// available delimiter characters.
  final public List StatementCollection() throws ParseException {
    List stmtList = new ArrayList();
    String stmt;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_SINGLELINE_COMMENT:
      case START_MULTILINE_COMMENT:
      case START_MULTILINE:
      case START_EXEC_PROC_CALL:
      case START_EXEC_PROC_OTHER:
      case START_SHELL_CALL:
      case START_OTHER_SQL_CHAR:
      case OTHER_SQL_DELIMITER:
      case OTHER_SQL_CHAR:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_EXEC_PROC_CALL:
      case START_EXEC_PROC_OTHER:
        stmt = CallableSQLStatement();
            stmtList.add(stmt);
        break;
      case START_SHELL_CALL:
        stmt = ShellCallStatement();
            stmtList.add(stmt);
        break;
      case START_OTHER_SQL_CHAR:
      case OTHER_SQL_DELIMITER:
      case OTHER_SQL_CHAR:
        stmt = OtherSQLStatement();
            stmtList.add(stmt);
        break;
      case START_MULTILINE:
        stmt = MultilineSQLStatement();
            stmtList.add(stmt);
        break;
      case START_SINGLELINE_COMMENT:
      case START_MULTILINE_COMMENT:
        CommentStatement();
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
      {if (true) return stmtList;}
    throw new Error("Missing return statement in function");
  }

// Comment statements can either be single line or multiline.
  final public void CommentStatement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case START_SINGLELINE_COMMENT:
      SingleLineCommentStatement();
      break;
    case START_MULTILINE_COMMENT:
      MultiLineCommentStatement();
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// Single line comments begin with a "--" string on a newline and are 
// terminated by newline.
  final public void SingleLineCommentStatement() throws ParseException {
    jj_consume_token(START_SINGLELINE_COMMENT);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SINGLELINE_COMMENT_CHAR:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
      jj_consume_token(SINGLELINE_COMMENT_CHAR);
    }
    jj_consume_token(END_SINGLELINE_COMMENT);
  }

// Multi line comments begin with "/*" on a newline and can contain
// multiple lines. They are terminated with a "*/" string at the end
// of the line.
  final public void MultiLineCommentStatement() throws ParseException {
    jj_consume_token(START_MULTILINE_COMMENT);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTILINE_COMMENT_CHAR:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
      jj_consume_token(MULTILINE_COMMENT_CHAR);
    }
    jj_consume_token(END_MULTILINE_COMMENT);
  }

// Multi line SQL statements are those that have a semi-colon (";") character
// terminating lines within the multi-line SQL. The trailing semi-colon 
// delimiter is not allowed for this type of statement.
  final public String MultilineSQLStatement() throws ParseException {
    StringBuffer cbuf = new StringBuffer(MULTILINE_SQL_PREFIX);
    jj_consume_token(START_MULTILINE);
            cbuf.append(getToken(0).image);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTILINE_CHAR:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_4;
      }
      jj_consume_token(MULTILINE_CHAR);
                cbuf.append(getToken(0).image);
    }
    jj_consume_token(MULTILINE_DELIMITER);
      {if (true) return cbuf.toString();}
    throw new Error("Missing return statement in function");
  }

// A Callable SQL statement is one which starts with "EXEC(UTE PROCEDURE) "
// or "{CALL ". The execute procedure call will be rewritten to a CALL form,
// since that is the form all JDBC drivers understand. The handler will 
// use a java.sql.CallableStatement to handle this call.
  final public String CallableSQLStatement() throws ParseException {
    StringBuffer ebuf = new StringBuffer(CALLABLE_SQL_PREFIX);
    boolean isCall = false;
    boolean hasOpeningParen = false;
    boolean hasClosingParen = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case START_EXEC_PROC_CALL:
      jj_consume_token(START_EXEC_PROC_CALL);
                ebuf.append(getToken(0).image);
                isCall = true;
      break;
    case START_EXEC_PROC_OTHER:
      jj_consume_token(START_EXEC_PROC_OTHER);
                ebuf.append("{CALL ");
                isCall = false;
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXEC_PROC_CONT_CHAR:
      case EXEC_PROC_OPEN_PAREN:
      case EXEC_PROC_CLOSE_PAREN:
      case EXEC_PROC_CHAR:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXEC_PROC_CHAR:
        jj_consume_token(EXEC_PROC_CHAR);
                ebuf.append(getToken(0).image);
        break;
      case EXEC_PROC_OPEN_PAREN:
        jj_consume_token(EXEC_PROC_OPEN_PAREN);
                ebuf.append(getToken(0).image);
                hasOpeningParen = true;
        break;
      case EXEC_PROC_CLOSE_PAREN:
        jj_consume_token(EXEC_PROC_CLOSE_PAREN);
                ebuf.append(getToken(0).image);
                hasClosingParen = true;
        break;
      case EXEC_PROC_CONT_CHAR:
        jj_consume_token(EXEC_PROC_CONT_CHAR);
                ebuf.append(" ");
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(EXEC_PROC_DELIMITER);
            if (!hasClosingParen && !hasOpeningParen) {
                ebuf.append("()");
            }
            if (!isCall) {
                ebuf.append("}");
            }
      {if (true) return ebuf.toString();}
    throw new Error("Missing return statement in function");
  }

// A Shell call statement represents a call to an operating system command
// or external utility. This may be useful for cleaning up temporary files
// or making SQL calls through the database client of your choice. A statement
// can span multiple lines using the backslash (\) continuation character. 
// The parser treats the shell call as a system process and will start up a 
// Java Runtime object for it. Note that the runtime will have no knowledge
// of the environment settings, so you need to provide full path names. Special
// features of the shell such as pipes and redirectors will also not work 
// unless you wrap the command in the shell processor, like so:
//   !/bin/sh -c (command) for Unix/Linux
//   !command.com /c (command) for Windows XP
//   !cmd.exe /c (command) for Windows NT
// The parenthesis are required. The recommended procedure would be to 
// simply invoke a shell script which does what you want as well as source
// environment variables that you may need.
  final public String ShellCallStatement() throws ParseException {
    StringBuffer sbuf = new StringBuffer(SHELL_CALL_PREFIX);
    int nestedBracketDepth = 0;
    jj_consume_token(START_SHELL_CALL);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SHELL_CONT_CHAR:
      case OPEN_PAREN:
      case CLOSE_PAREN:
      case SHELL_CALL_CHAR:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SHELL_CALL_CHAR:
        jj_consume_token(SHELL_CALL_CHAR);
                sbuf.append(getToken(0).image);
        break;
      case SHELL_CONT_CHAR:
        jj_consume_token(SHELL_CONT_CHAR);
                sbuf.append(" ");
        break;
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
                if (nestedBracketDepth == 0) {
                    sbuf.append("'");
                }
                nestedBracketDepth++;
        break;
      case CLOSE_PAREN:
        jj_consume_token(CLOSE_PAREN);
                nestedBracketDepth--;
                if (nestedBracketDepth == 0) {
                    sbuf.append("'");
                }
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(SHELL_CALL_DELIMITER);
      {if (true) return sbuf.toString();}
    throw new Error("Missing return statement in function");
  }

// The Other SQL statement represents an SQL statement that is not a CREATE
// or REPLACE call (MultilineSQLStatement) or an EXEC(UTE PROCEDURE) call
// (CallableSQLStatement). SQL statements such as SELECT, INSERT, UPDATE,
// DELETE, RENAME, DROP, etc, fall into this category. The SQL statement
// can contain newlines which will be transformed by the parser into white
// space. The parser will use a java.sql.PreparedStatement to process this
// statement.
  final public String OtherSQLStatement() throws ParseException {
    StringBuffer obuf = new StringBuffer(OTHER_SQL_PREFIX);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_OTHER_SQL_CHAR:
      case OTHER_SQL_CHAR:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_OTHER_SQL_CHAR:
        jj_consume_token(START_OTHER_SQL_CHAR);
                obuf.append(getToken(0).image);
        break;
      case OTHER_SQL_CHAR:
        jj_consume_token(OTHER_SQL_CHAR);
                obuf.append(getToken(0).image);
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(OTHER_SQL_DELIMITER);
      {if (true) return obuf.toString();}
    throw new Error("Missing return statement in function");
  }

  public IncludeFileParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[14];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x180007f0,0x180007f0,0x1,0x30,0x1000,0x4000,0x10000,0x180,0x2e0000,0x2e0000,0x7400000,0x7400000,0x10000400,0x10000400,};
   }

  public IncludeFileParser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new IncludeFileParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  public IncludeFileParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new IncludeFileParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  public IncludeFileParser(IncludeFileParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  public void ReInit(IncludeFileParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[29];
    for (int i = 0; i < 29; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 14; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 29; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
